ls                 # to show the list of items in current directory
ls -l              # Detailed listing
ls -a              # Show hidden files
ls -lart           # to get info about permissions
ls -lh



cd /path/to/dir    # Change directory
cd ..              # Go up one directory
cd ../             # to move to root directory


pwd                # to show the path of current directory


mkdir              # to create a directory
rmdir              # to remove a directory
rm -r dir_name     # Remove directory with files
rm file.txt        # Delete file


touch file.txt     # Create empty file
cp file1 file2     # Copy file
cp -r dir1 dir2    # Copy directory
mv file1 newname   # Rename/move file or       
mv file1 folder/file1


vim main.py         # terminal editor (to create and manipulate files)
i                   # Enter insert mode (start typing)
Esc                 # Return to normal mode
:w                  # Save (write)
:q                  # Quit
:wq                 # Save and quit
:q!                 # Quit without saving
dd                  # Delete line
yy                  # Copy line
p                   # Paste line
x                   # delete character (equal to dl)
s                   # substitute character (equal to cl)
:e                    {name of file} open file for editing
:help {topic}         open help
:help :w              opens help for the :w command
:help w               opens help for the w movement
~                     flips the case of a character



nano file.txt       # terminal editor (to create and manipulate files)
Ctrl + O            # Save (write out)
Ctrl + X            # Exit
Ctrl + K            # Cut line
Ctrl + U            # Paste line
Ctrl + W            # Search


cat file.txt        # View file content
less file.txt       # View file page by page
head file.txt       # First 10 lines
tail file.txt       # Last 10 lines
tail -f logfile     # Watch live logs

man ls              # to get all info about ls command


chmod               # Change permissions (rwxr-xr-x)
  eg: chmod 744 file.txt 

chmod +x file       # makes file executable

chown               # Change ownership
  eg: chown newuser file.txt
  eg: chown newuser:newgroup file.txt


sudo apt update                # Update package list
sudo apt upgrade               # Upgrade packages
sudo apt install pkg_name      # Install package
sudo apt remove pkg_name       # Remove package
dpkg -l                        # List installed packages


tar                 # create or extract compressed archieved files

tar cf hello.tar hello.py main.py 

will create a tar file , a compressed combination of 2 files

# x: extract files from an archive
# t: list the contents of an archive
# r: append files to an existing archive
# z: use gzip compression
# j: use bzip2 compression
# cf: create file
# xf: extract file

tar -xvf files.tar             # Extract tar

zip file.zip file1 file2       # Zip files
unzip file.zip                 # Unzip


gzip file.txt      # to compress a file
gunzip file.txt    # to decompress a file


ssh username@server_address   # will direct you to other server

scp myfile.txt user@remotehost:/home/user/    # to copy a file from one server to other



ifconfig           # display or configure network interfaces

netstat            # display network connection information

route              # view or configure network routing tables

top                # display system resource usage and processes

htop               # to get view of all running processes

ps                 # display information about running processes

ps -ef             # detailed

ps -ef | grep init   # grep used for searching specific process

kill processid    # to kill a process

ps aux            # Show all processes
kill 1234         # Kill process by PID
kill -9 1234      # Force kill
jobs              # List background jobs
bg                # Resume job in background
fg                # Resume job in foreground



find / -name file.txt         # Find file by name
find . -type f -name "*.py"   # Find Python files
grep "keyword" file.txt       # Search inside file
grep -r "keyword" path        # Search recursively


uname -a          # Kernel info
hostname          # System hostname
uptime            # System running time
df -h             # Disk usage
du -sh *          # Folder sizes
free -h           # Memory usage
whoami            # Current user
id                # User ID and groups
which ls          # tells folder of pkg 
finger username   # to get info about other users
locate filename   # to find the file in directory
sort filename     # will sort elements in the file
uniq filename     # will give unique values from file

sort -u -c alpha.txt
Here‚Äôs what each flag means:
sort ‚Üí sorts the file.
-u ‚Üí removes duplicates (unique).
-c ‚Üí check only, don‚Äôt output sorted text. Instead, report if the file is sorted.


sort -u alpha.txt -o alpha.txt
This will sort the file, remove duplicates, and save back to alpha.txt.


adduser newuser   # Add new user
passwd username   # Change password
userdel username  # Delete User
su - username     # Switch user

tmux                   # Start a new tmux session
tmux new -s mysession  # Start session with name
tmux ls                # List all sessions
tmux attach -t mysession   # Attach to a session
tmux kill-session -t mysession  # Kill a session
exit                   # Exit shell inside tmux (ends pane/window)

tmux new -s project      # Start new session "project"
Ctrl+b c                 # Create a new window
Ctrl+b n                 # Switch between Windows
Ctrl+b %                 # Split pane vertically
Ctrl+b "                 # Split pane horizontally
Ctrl+b o                 # Switch between panes
Ctrl+b d                 # Detach (session keeps running)
Ctrl+b ,                 # Rename the Window
Ctrl+b w                 # List of Everything
tmux a -t project   # Reattach later


alias ..="cd .."
alias ...="cd ../.."
alias update="sudo apt update && sudo apt upgrade -y"
alias gs="git status"
alias gp="git pull"
alias dc="docker-compose"
alias v="vim"
alias n="nano"

# Make shorthands for common flags
alias ll="ls -lh"

alias mv="mv -i"           # -i prompts before overwrite
alias mkdir="mkdir -p"     # -p make parent dirs as needed
alias df="df -h"           # -h prints human readable format

unalias la


ls > files.txt        # Save output to file (overwrite)
ls >> files.txt       # Append output to file
ls 2> errors.txt      # Redirect errors
command > out.txt 2>&1   # Redirect both output and error


cmp  # compare file
diff # diff bw 2 files


cat /etc/passwd | grep "/bin/bash" | cut -d: -f1 > users.txt
üëâ Extracts all usernames with bash shell and saves to users.txt.



find . -type f -name "*.log" | xargs grep "ERROR"
üëâ Find all .log files and search for ‚ÄúERROR‚Äù inside them.



‚ÄúList only .py files and count them.‚Äù

ls *.py | wc -l


‚ÄúFind processes containing nginx and kill them.‚Äù

ps aux | grep nginx | awk '{print $2}' | xargs kill -9


missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello

curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2

$0 - Name of the script
$1 to $9 - Arguments to the script. $1 is the first argument and so on.
$@ - All the arguments
$# - Number of arguments
$? - Return code of the previous command
$$ - Process identification number (PID) for the current script
!! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !!
$_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . or Alt+.



false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

true ; echo "This will always run"
# This will always run

false ; echo "This will always run"
# This will always run


Rule

command1 || command2

Runs command2 only if command1 fails (non-zero exit code).

command1 && command2

Runs command2 only if command1 succeeds (exit code 0).

Commands can also be separated within the same line using a semicolon ;


# Find all directories named src
find . -name src -type d

# Find all python files that have a folder named test in their path
find . -path '*/test/*.py' -type f

# Find all files modified in the last day
find . -mtime -1

# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name '*.tar.gz'

# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;

# Find all PNG files and convert them to JPG
find . -name '*.png' -exec magick {} {}.jpg \;

# Find all python files where I used the requests library
rg -t py 'import requests'

# Find all files (including hidden files) without a shebang line
rg -u --files-without-match "^#\!"

# Find all matches of foo and print the following 5 lines
rg foo -A 5

# Print statistics of matches (# of matched lines and files )
rg --stats PATTERN


. means ‚Äúany single character‚Äù except newline
* zero or more of the preceding match
+ one or more of the preceding match
[abc] any one character of a, b, and c
(RX1|RX2) either something that matches RX1 or RX2
^ the start of the line
$ the end of the line

sort alpha.txt | uniq
sort -u alpha.txt

history | awk '{$1="";print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10


Git command-line interface
To avoid duplicating information, we‚Äôre not going to explain the commands below in detail. See the highly recommended Pro Git for more information, or watch the lecture video.

Basics
git help <command>: get help for a git command
git init: creates a new git repo, with data stored in the .git directory
git status: tells you what‚Äôs going on
git add <filename>: adds files to staging area
git commit: creates a new commit


Write good commit messages!
Even more reasons to write good commit messages!
git log: shows a flattened log of history
git log --all --graph --decorate: visualizes history as a DAG
git diff <filename>: show changes you made relative to the staging area
git diff <revision> <filename>: shows differences in a file between snapshots
git checkout <revision>: updates HEAD (and current branch if checking out a branch)


Branching and merging
git branch: shows branches
git branch <name>: creates a branch
git checkout -b <name>: creates a branch and switches to it
same as git branch <name>; git checkout <name>
git merge <revision>: merges into current branch
git mergetool: use a fancy tool to help resolve merge conflicts
git rebase: rebase set of patches onto a new base


Remotes
git remote: list remotes
git remote add <name> <url>: add a remote
git push <remote> <local branch>:<remote branch>: send objects to remote, and update remote reference
git branch --set-upstream-to=<remote>/<remote branch>: set up correspondence between local and remote branch
git fetch: retrieve objects/references from a remote
git pull: same as git fetch; git merge
git clone: download repository from remote


Undo
git commit --amend: edit a commit‚Äôs contents/message
git reset HEAD <file>: unstage a file
git checkout -- <file>: discard changes


Advanced Git
git config: Git is highly customizable
git clone --depth=1: shallow clone, without entire version history
git add -p: interactive staging
git rebase -i: interactive rebasing
git blame: show who last edited which line
git stash: temporarily remove modifications to working directory
git bisect: binary search history (e.g. for regressions)
.gitignore: specify intentionally untracked files to ignore



Event Profiling
As it was the case for strace for debugging, you might want to ignore the specifics of the code that you are running and treat it like a black box when profiling. The perf command abstracts CPU differences away and does not report time or memory, but instead it reports system events related to your programs. For example, perf can easily report poor cache locality, high amounts of page faults or livelocks. Here is an overview of the command:

perf list - List the events that can be traced with perf
perf stat COMMAND ARG1 ARG2 - Gets counts of different events related to a process or command
perf record COMMAND ARG1 ARG2 - Records the run of a command and saves the statistical data into a file called perf.data
perf report - Formats and prints the data collected in perf.data


==========
Review Meta Programming Lecture 
==========

$ printf 'hello' | sha1sum
aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
$ printf 'Hello' | sha1sum 
f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0

----------------------------------------
Symmetric cryptography
keygen() -> key  (this function is randomized)

encrypt(plaintext: array<byte>, key) -> array<byte>  (the ciphertext)
decrypt(ciphertext: array<byte>, key) -> array<byte>  (the plaintext)


--------------------------------------------

Asymmetric cryptography
The term ‚Äúasymmetric‚Äù refers to there being two keys, with two different roles. A private key, as its name implies, is meant to be kept private, while the public key can be publicly shared and it won‚Äôt affect security (unlike sharing the key in a symmetric cryptosystem). Asymmetric cryptosystems provide the following set of functionality, to encrypt/decrypt and to sign/verify:

keygen() -> (public key, private key)  (this function is randomized)

encrypt(plaintext: array<byte>, public key) -> array<byte>  (the ciphertext)
decrypt(ciphertext: array<byte>, private key) -> array<byte>  (the plaintext)

sign(message: array<byte>, private key) -> array<byte>  (the signature)
verify(message: array<byte>, signature: array<byte>, public key) -> bool  (whether or not the signature is valid)

